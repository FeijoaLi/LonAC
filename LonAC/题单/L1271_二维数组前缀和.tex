\documentclass{ctexart}
\ctexset{
    section = {
        titleformat = \raggedright,
        name = {,、},
        number = \chinese{section}
    }
}
\usepackage[a4paper,top=2.54cm,bottom=2.54cm,left=3.18cm,right=3.18cm]{geometry}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{tikz}
\usepackage{multirow}
\usepackage{array}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{pifont}  
\usepackage{xcolor}
%\usepackage{colortbl}  % 添加这一行来支持 \cellcolor
\usepackage{listings}
\usepackage{enumitem}

\definecolor{lightpink}{RGB}{184,83,182}
\definecolor{codebg}{RGB}{245,245,245}
\definecolor{emphcolor}{RGB}{199,21,133}
\definecolor{important}{RGB}{220,20,60}
\definecolor{highlight}{RGB}{0,100,0}
\definecolor{sumregion}{RGB}{255,200,200}
\definecolor{currentcell}{RGB}{255,0,0}

\lstset{
basicstyle=\ttfamily\small,
language=C++,
frame=single,
breaklines=true,
backgroundcolor=\color{codebg},
escapeinside=``,
commentstyle=\color{green!60!black},
keywordstyle=\color{blue},
stringstyle=\color{red},
rulecolor=\color{black},
framesep=5pt,
xleftmargin=10pt,
xrightmargin=10pt
}

\setlist[enumerate,1]{label=\arabic*., leftmargin=2em}
\setlist[enumerate,2]{label=（\arabic*）, leftmargin=3em}
\setlist[enumerate,3]{label=\roman*, leftmargin=4em}

\pagestyle{fancy}
\fancyhf{}
\cfoot{解码未来AI教育 \quad 编程题解}
\renewcommand{\headrulewidth}{0pt}

\begin{document}

\section*{L1530 : 二维数组前缀和 \ding{78}\ding{78}} 

\subsection*{题目描述}
给定一个 $n$ 行 $m$ 列的二维数组，你需要计算该数组的\textcolor{emphcolor}{\textbf{前缀和}}。

所谓前缀和是指：对于每个位置 $(i,j)$，求出从左上角 $(0,0)$ 到当前位置 $(i,j)$ 的所有元素的和。

\[
a = 
\begin{bmatrix}
1 & 2 & 3\\
4 & 5 & 6\\
7 & 8 & 9
\end{bmatrix}
\quad\Rightarrow\quad
s =
\begin{bmatrix}
1 & 3 & 6\\
5 & 12 & 21\\
12 & 27 & 45
\end{bmatrix}
\]

\subsection*{输入输出格式}
\textbf{输入：}第一行包含两个整数 $n, m$（$1 \le n, m \le 1000$），表示二维数组的行数和列数。\par
\qquad\quad 接下来的 $n$ 行，每行包含 $m$ 个整数，表示二维数组的元素。\par
\qquad\quad 每个元素的值满足 $-10^3 \le a[i][j] \le 10^3$。\par
\textbf{输出：}输出 $n$ 行，每行包含 $m$ 个整数，表示前缀和数组对应位置的值。\par
\qquad\quad 每行数之间用一个空格分隔，且\textcolor{red}{每行末尾不要有空格}。

\begin{table}[h]
\centering
\begin{tabularx}{\textwidth}{|X|X|}
\hline
\textbf{输入示例} & \textbf{输出示例}     \\    
\hline
3 3 & 1 3 6 \\ 
1 2 3 & 5 12 21 \\ 
4 5 6 & 12 27 45 \\ 
7 8 9 & \\ 
\hline
\end{tabularx}  
\end{table}

\subsection*{样例解释}
以计算 $s[1][2]$（第二行第三列）为例，演示二维前缀和的计算过程：
\begin{align*}
s[1][2] &= a[0][0] + a[0][1] + a[0][2] + a[1][0] + a[1][1] + a[1][2] \\
&= 1 + 2 + 3 + 4 + 5 + 6 \\
&= 21
\end{align*}

\subsection*{算法分析}

\begin{enumerate}
\item \textcolor{highlight}{\textbf{直接计算方法}}\\
对于每个位置 $(i,j)$，直接计算从 $(0,0)$ 到 $(i,j)$ 的所有元素之和：
\begin{lstlisting}[language=C++]
for(int x = 0; x <= i; x++) {
    for(int y = 0; y <= j; y++) {
        s[i][j] += a[x][y];
    }
}   
\end{lstlisting}

这种方法的时间复杂度为 $O(n^2 \cdot m^2)$，会导致超时。

\item \textcolor{highlight}{\textbf{优化方法：前缀和}}\\
利用已计算的前缀和来计算新的前缀和，可以大大降低时间复杂度。以下以 $s[2][2]$ 的计算为例进行说明。

\begin{enumerate}
\item \textcolor{highlight}{\textbf{区域划分}}\\
我们用不同颜色表示不同的前缀和区域，$s[2][2]$ = 整个矩形内所有数字的和 ：

\begin{center}
\begin{tabular}{ccc}
$\begin{bmatrix}
\textcolor{blue}{1} & \textcolor{blue}{2} & \textcolor{blue}{3}\\
\textcolor{blue}{4} & \textcolor{blue}{5} & \textcolor{blue}{6}\\
7 & 8 & \textcolor{orange}{9}
\end{bmatrix}$
&
$\begin{bmatrix}
\textcolor{red}{1} & \textcolor{red}{2} & 3\\
\textcolor{red}{4} & \textcolor{red}{5} & 6\\
\textcolor{red}{7} & \textcolor{red}{8} & \textcolor{orange}{9}
\end{bmatrix}$
&
$\begin{bmatrix}
\textcolor{green}{1} & \textcolor{green}{2} & 3\\
\textcolor{green}{4} & \textcolor{green}{5} & 6\\
7 & 8 & \textcolor{orange}{9}
\end{bmatrix}$
\end{tabular}
\end{center}

\begin{itemize}
\item 蓝色部分的数字和表示 $s[1][2]$，红色部分的数字和表示 $s[2][1]$，
绿色部分的数字和表示 $s[1][1]$（红蓝重叠的部分），橘色部分的数字表示 $a[2][2]$。
\item 整个矩形的和 = 蓝色区域 + 红色区域 - 绿色区域 + 橘色区域
\item 用符号表示就是： 
$s[2][2] = 
\textcolor{blue}{s[1][2]} + \textcolor{red}{s[2][1]} - 
\textcolor{green}{s[1][1]} + \textcolor{orange}{a[2][2]}$
\item 得出通用公式：$s[x][y] = 
\textcolor{blue}{s[x-1][y]} + \textcolor{red}{s[x][y-1]} - 
\textcolor{green}{s[x-1][y-1]} + \textcolor{orange}{a[x][y]}
$\\
当前位置前缀和 = \textcolor{blue}{左前缀和} + 
\textcolor{red}{上前缀和} - 
\textcolor{green}{左上角前缀和} + 
\textcolor{orange}{当前位置的值}
\item 我们利用这个公式，从左上角到右下角的顺序，计算$s[i][j]$，就可以得到所有 $s[x][y]$ 的值。
\end{itemize}



\end{enumerate}
\end{enumerate}

\subsection*{代码实现：}
\text{处理前缀和}
\begin{lstlisting}
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        s[i][j] += s[i - 1][j] + s[i][j - 1] - 
                   s[i - 1][j - 1] + a[i - 1][j - 1];
    }
}
\end{lstlisting}

\text{输出格式}
\begin{lstlisting}
`//注意行末不能有多余的空格`
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
        cout << a[i][j] << "` `\n"[j == m - 1];
    }
}
\end{lstlisting}

\subsection*{拓展思考}
\begin{itemize}
    \item 如果换成三维，如何求 $a[i][j][k]$ 的前缀和？
    \item 如果要求从 $(x1,y1)$ 到 $(x2,y2)$ 的区域和，该如何计算？
\end{itemize}

\end{document}